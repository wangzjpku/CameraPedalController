; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\smpl_nutiny_120.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\smpl_nutiny_120.d --cpu=Cortex-M0 --apcs=interwork -O0 -Otime -I.\ -I..\..\..\..\CMSIS\CM0\CoreSupport -I..\..\..\..\CMSIS\CM0\DeviceSupport\Nuvoton\NUC1xx -I..\..\..\Include -I..\..\..\Include\Driver -Id:\Keil\ARM\RV31\Inc -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\?ST\STM32F10x -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\smpl_nutiny_120.crf Smpl_NUTINY_120.c]
                          THUMB

                          AREA ||i.InitSystem||, CODE, READONLY, ALIGN=2

                  InitSystem PROC
;;;94      */
;;;95     void InitSystem(void)
000000  b510              PUSH     {r4,lr}
;;;96     {
;;;97         uint32_t i;	
;;;98         UNLOCKREG();
000002  2059              MOVS     r0,#0x59
000004  4929              LDR      r1,|L1.172|
000006  6008              STR      r0,[r1,#0]
000008  2016              MOVS     r0,#0x16
00000a  6008              STR      r0,[r1,#0]
00000c  2088              MOVS     r0,#0x88
00000e  6008              STR      r0,[r1,#0]
;;;99         SYSCLK->PWRCON.XTL12M_EN = 1;   //设定12M外部晶振
000010  4827              LDR      r0,|L1.176|
000012  6800              LDR      r0,[r0,#0]
000014  0840              LSRS     r0,r0,#1
000016  0040              LSLS     r0,r0,#1
000018  1c40              ADDS     r0,r0,#1
00001a  4925              LDR      r1,|L1.176|
00001c  6008              STR      r0,[r1,#0]
;;;100        DrvSYS_Delay(5000);             //等待时钟就绪
00001e  4825              LDR      r0,|L1.180|
000020  f7fffffe          BL       DrvSYS_Delay
;;;101        DrvSYS_SelectPLLSource(E_SYS_EXTERNAL_12M);   //选择12MHz为PLL输入
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       DrvSYS_SelectPLLSource
;;;102        DrvSYS_Open(50000000);          //打开50MHz
00002a  4823              LDR      r0,|L1.184|
00002c  f7fffffe          BL       DrvSYS_Open
;;;103        LOCKREG();
000030  2000              MOVS     r0,#0
000032  491e              LDR      r1,|L1.172|
000034  6008              STR      r0,[r1,#0]
;;;104    		  
;;;105    
;;;106        /* 下面对GPIO管脚进行配置 */
;;;107        for(i=0;i<15;i++)
000036  2400              MOVS     r4,#0
000038  e009              B        |L1.78|
                  |L1.58|
;;;108        {
;;;109            DrvGPIO_Open(pupin[i].Port, pupin[i].Num, E_IO_OUTPUT);  //配置输入管脚
00003a  00e2              LSLS     r2,r4,#3
00003c  4b1f              LDR      r3,|L1.188|
00003e  18d2              ADDS     r2,r2,r3
000040  6851              LDR      r1,[r2,#4]
000042  00e2              LSLS     r2,r4,#3
000044  5c98              LDRB     r0,[r3,r2]
000046  2201              MOVS     r2,#1
000048  f7fffffe          BL       DrvGPIO_Open
00004c  1c64              ADDS     r4,r4,#1              ;107
                  |L1.78|
00004e  2c0f              CMP      r4,#0xf               ;107
000050  d3f3              BCC      |L1.58|
;;;110        }
;;;111        while(i<19)
000052  e009              B        |L1.104|
                  |L1.84|
;;;112        {
;;;113            DrvGPIO_Open(pupin[i].Port, pupin[i].Num, E_IO_OUTPUT); //配置输出管脚
000054  00e2              LSLS     r2,r4,#3
000056  4b19              LDR      r3,|L1.188|
000058  18d2              ADDS     r2,r2,r3
00005a  6851              LDR      r1,[r2,#4]
00005c  00e2              LSLS     r2,r4,#3
00005e  5c98              LDRB     r0,[r3,r2]
000060  2201              MOVS     r2,#1
000062  f7fffffe          BL       DrvGPIO_Open
;;;114            i++;
000066  1c64              ADDS     r4,r4,#1
                  |L1.104|
000068  2c13              CMP      r4,#0x13              ;111
00006a  d3f3              BCC      |L1.84|
;;;115        }	
;;;116    		
;;;117    		GPD_0 = 1;
00006c  2001              MOVS     r0,#1
00006e  4914              LDR      r1,|L1.192|
000070  6008              STR      r0,[r1,#0]
;;;118    		GPD_1 = 1;	
000072  6048              STR      r0,[r1,#4]
;;;119    		GPA_12 = 1;
000074  4912              LDR      r1,|L1.192|
000076  39c0              SUBS     r1,r1,#0xc0
000078  6308              STR      r0,[r1,#0x30]
;;;120    		
;;;121    		GPD_2 = 0;
00007a  2000              MOVS     r0,#0
00007c  4910              LDR      r1,|L1.192|
00007e  6088              STR      r0,[r1,#8]
;;;122    		GPD_3 = 0;
000080  60c8              STR      r0,[r1,#0xc]
;;;123    		GPB_8 = 0;
000082  490f              LDR      r1,|L1.192|
000084  3980              SUBS     r1,r1,#0x80
000086  6208              STR      r0,[r1,#0x20]
;;;124    
;;;125    		GPC_0 = 0;	
000088  490d              LDR      r1,|L1.192|
00008a  3940              SUBS     r1,r1,#0x40
00008c  6008              STR      r0,[r1,#0]
;;;126    		GPC_1 = 0;
00008e  6048              STR      r0,[r1,#4]
;;;127    		GPC_2 = 0;
000090  6088              STR      r0,[r1,#8]
;;;128    		
;;;129    		GPC_8 = 1;
000092  2001              MOVS     r0,#1
000094  6208              STR      r0,[r1,#0x20]
;;;130    		GPC_12 = 0;
000096  2000              MOVS     r0,#0
000098  6308              STR      r0,[r1,#0x30]
;;;131    		GPA_15 = 1;
00009a  2001              MOVS     r0,#1
00009c  4908              LDR      r1,|L1.192|
00009e  39c0              SUBS     r1,r1,#0xc0
0000a0  63c8              STR      r0,[r1,#0x3c]
;;;132    		
;;;133        UART_Configuration();   //初始化UART
0000a2  f7fffffe          BL       UART_Configuration
;;;134        TIMER_Configuration();  //初始化TIMER    
0000a6  f7fffffe          BL       TIMER_Configuration
;;;135    //		PWM_Configuration( PWM_Frequence , 25 );	
;;;136    }
0000aa  bd10              POP      {r4,pc}
;;;137    
                          ENDP

                  |L1.172|
                          DCD      0x50000100
                  |L1.176|
                          DCD      0x50000200
                  |L1.180|
                          DCD      0x00001388
                  |L1.184|
                          DCD      0x02faf080
                  |L1.188|
                          DCD      pupin
                  |L1.192|
                          DCD      0x500042c0

                          AREA ||i.PWM_Configuration||, CODE, READONLY, ALIGN=1

                  PWM_Configuration PROC
;;;137    
;;;138    void PWM_Configuration(int frequence , int pulseratio)
000000  b57f              PUSH     {r0-r6,lr}
;;;139    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;140    S_DRVPWM_TIME_DATA_T sPt;
;;;141    /* PWM Timer property */ 
;;;142    sPt.u8Mode = DRVPWM_AUTO_RELOAD_MODE; /*自动重载模式*/ 
000006  2101              MOVS     r1,#1
000008  4668              MOV      r0,sp
00000a  7001              STRB     r1,[r0,#0]
;;;143    sPt.u32Frequency = frequence; // 100 /*PWM 频率 为100HZ即10000us为一周期*/ 
00000c  9401              STR      r4,[sp,#4]
;;;144    sPt.u8HighPulseRatio = pulseratio; //测试发现实际有误差矫正系数 //25; /* 高脉冲宽度时间所占周期的百分比: 25%*/ 
00000e  7045              STRB     r5,[r0,#1]
;;;145    sPt.i32Inverter = 0; /*反向关闭*/
000010  2000              MOVS     r0,#0
000012  9003              STR      r0,[sp,#0xc]
;;;146    /* Enable PWM clock */
;;;147    DrvPWM_Open(); //打开 PWM 时钟并且复位PWM
000014  f7fffffe          BL       DrvPWM_Open
;;;148    /* Select PWM engine clock */
;;;149    //DrvPWM_SelectClockSource(DRVPWM_TIMER0, DRVPWM_EXT_12M);//设置PWM 定时器0 为外部12 MHz crystal 时钟
;;;150    DrvSYS_SelectIPClockSource(E_SYS_PWM01_CLKSRC,0); //使用外设时注意必须设置该外设的时钟 设置PWM01的时钟源为外部12MHZ 
000018  2100              MOVS     r1,#0
00001a  2007              MOVS     r0,#7
00001c  f7fffffe          BL       DrvSYS_SelectIPClockSource
;;;151    /* Set PWM Timer0 Configuration */
;;;152    DrvPWM_SetTimerClk(DRVPWM_TIMER0, &sPt); //配置PWM 定时器0的一些参数 如配置频率/脉冲/模式/逆转功能
000020  4669              MOV      r1,sp
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       DrvPWM_SetTimerClk
;;;153    /* Enable Output for PWM Timer0 */
;;;154    DrvPWM_SetTimerIO(DRVPWM_TIMER0, 1); //使能或关闭PWM定时器0对应的IO口输出使能
000028  2101              MOVS     r1,#1
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       DrvPWM_SetTimerIO
;;;155    /* Set PWM pins */
;;;156    DrvGPIO_InitFunction(E_FUNC_PWM01); //指定多功能引脚 即 PA12，PA13为PWM0和PWM1
000030  2030              MOVS     r0,#0x30
000032  f7fffffe          BL       DrvGPIO_InitFunction
;;;157    /* Enable the PWM Timer 0 */
;;;158    DrvPWM_Enable(DRVPWM_TIMER0, 1); //使能/关闭PWM定时器0 
000036  2101              MOVS     r1,#1
000038  2000              MOVS     r0,#0
00003a  f7fffffe          BL       DrvPWM_Enable
;;;159    }
00003e  bd7f              POP      {r0-r6,pc}
;;;160    
                          ENDP


                          AREA ||i.Send_Uart_Call||, CODE, READONLY, ALIGN=2

                  Send_Uart_Call PROC
;;;202    
;;;203    void Send_Uart_Call(uint8_t * command )
000000  b510              PUSH     {r4,lr}
;;;204    {
000002  4604              MOV      r4,r0
;;;205      DrvUART_Write(UART_PORT1,command,4);
000004  2204              MOVS     r2,#4
000006  4621              MOV      r1,r4
000008  0490              LSLS     r0,r2,#18
00000a  f7fffffe          BL       DrvUART_Write
;;;206    		
;;;207    	GPA_15 = 0;
00000e  2000              MOVS     r0,#0
000010  4908              LDR      r1,|L3.52|
000012  63c8              STR      r0,[r1,#0x3c]
;;;208    	delay_loop();
000014  f7fffffe          BL       delay_loop
;;;209    	delay_loop();
000018  f7fffffe          BL       delay_loop
;;;210    	delay_loop();
00001c  f7fffffe          BL       delay_loop
;;;211    	delay_loop();
000020  f7fffffe          BL       delay_loop
;;;212    	delay_loop();
000024  f7fffffe          BL       delay_loop
;;;213    	delay_loop();
000028  f7fffffe          BL       delay_loop
;;;214    	GPA_15 = 1;  //LED闪烁1次 收到数据
00002c  2001              MOVS     r0,#1
00002e  4901              LDR      r1,|L3.52|
000030  63c8              STR      r0,[r1,#0x3c]
;;;215    }
000032  bd10              POP      {r4,pc}
;;;216    
                          ENDP

                  |L3.52|
                          DCD      0x50004200

                          AREA ||i.TIMER_Configuration||, CODE, READONLY, ALIGN=2

                  TIMER_Configuration PROC
;;;167     */
;;;168    void TIMER_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;169    {
;;;170        DrvTIMER_Init();  //初始化定时器
000002  f7fffffe          BL       DrvTIMER_Init
;;;171        DrvSYS_SelectIPClockSource(E_SYS_TMR0_CLKSRC,0x00);   //设定TIMER0的时钟源为外部12MHZ 
000006  2100              MOVS     r1,#0
000008  2002              MOVS     r0,#2
00000a  f7fffffe          BL       DrvSYS_SelectIPClockSource
;;;172        DrvTIMER_Open(E_TMR0,TIMER0_FREQ,E_PERIODIC_MODE);  //设定定时器timer0的tick周期，并且启动定时器：TIMER0_FREQ，周期模式
00000e  2201              MOVS     r2,#1
000010  4908              LDR      r1,|L4.52|
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       DrvTIMER_Open
;;;173        DrvTIMER_SetTimerEvent(E_TMR0, 1, (TIMER_CALLBACK)Timer0_Callback, 0);  //安装一个定时处理事件到 timer0通道
000018  2300              MOVS     r3,#0
00001a  4a07              LDR      r2,|L4.56|
00001c  2101              MOVS     r1,#1
00001e  4618              MOV      r0,r3
000020  f7fffffe          BL       DrvTIMER_SetTimerEvent
;;;174        DrvTIMER_EnableInt(E_TMR0);   //使能定时器中断 TIMER0->TCSR.IE = 1
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       DrvTIMER_EnableInt
;;;175        DrvTIMER_Start(E_TMR0); //定时器timer0开始计数 TIMER0->TCSR.CEN = 1;
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       DrvTIMER_Start
;;;176    }
000030  bd10              POP      {r4,pc}
;;;177    
                          ENDP

000032  0000              DCW      0x0000
                  |L4.52|
                          DCD      0x000009c4
                  |L4.56|
                          DCD      Timer0_Callback

                          AREA ||i.Timer0_Callback||, CODE, READONLY, ALIGN=2

                  Timer0_Callback PROC
;;;222     */
;;;223    void Timer0_Callback(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;224    {	
;;;225    	
;;;226    	uint8_t command[6]={0x0,0x0,0x0,0x0,0x0,0x0}; //0 0xff 1 命令区分停止和速度 2开关 或者速度 4 0xff
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
000006  9001              STR      r0,[sp,#4]
;;;227    
;;;228    // DrvUART_Read(UART_PORT1,command,4);	
;;;229    
;;;230    // PD0 PD1 PA12 // 黄色 蓝色 红色
;;;231    
;;;232    #if 0  // For test
;;;233    		command[0] = 0xff;	
;;;234    		command[1] = 0x01;  
;;;235    		command[2] = 0x00;
;;;236    		command[3] = 0x10;
;;;237    		Send_Uart_Call(command );	  
;;;238    #endif 
;;;239    
;;;240      if ( ( GPD_0 == 0 ) && ( GPD_0 != keyboard[0] ) )
000008  4847              LDR      r0,|L5.296|
00000a  6800              LDR      r0,[r0,#0]
00000c  2800              CMP      r0,#0
00000e  d111              BNE      |L5.52|
000010  4845              LDR      r0,|L5.296|
000012  6800              LDR      r0,[r0,#0]
000014  4945              LDR      r1,|L5.300|
000016  7809              LDRB     r1,[r1,#0]  ; keyboard
000018  4288              CMP      r0,r1
00001a  d00b              BEQ      |L5.52|
;;;241    	{
;;;242        // GPD0 被按下 
;;;243    		command[0] = 0xff;	
00001c  21ff              MOVS     r1,#0xff
00001e  4668              MOV      r0,sp
000020  7001              STRB     r1,[r0,#0]
;;;244    		command[1] = 0x01;  
000022  2101              MOVS     r1,#1
000024  7041              STRB     r1,[r0,#1]
;;;245    		command[2] = 0x00;
000026  2100              MOVS     r1,#0
000028  7081              STRB     r1,[r0,#2]
;;;246    		command[3] = 0x10;
00002a  2110              MOVS     r1,#0x10
00002c  70c1              STRB     r1,[r0,#3]
;;;247    		Send_Uart_Call(command );		
00002e  f7fffffe          BL       Send_Uart_Call
000032  e014              B        |L5.94|
                  |L5.52|
;;;248    
;;;249      }else if ( ( GPD_0 == 1 ) && ( GPD_0 != keyboard[0] ) )
000034  483c              LDR      r0,|L5.296|
000036  6800              LDR      r0,[r0,#0]
000038  2801              CMP      r0,#1
00003a  d110              BNE      |L5.94|
00003c  483a              LDR      r0,|L5.296|
00003e  6800              LDR      r0,[r0,#0]
000040  493a              LDR      r1,|L5.300|
000042  7809              LDRB     r1,[r1,#0]  ; keyboard
000044  4288              CMP      r0,r1
000046  d00a              BEQ      |L5.94|
;;;250      {
;;;251    		//GPD0 被抬起
;;;252    		command[0] = 0xff;	
000048  21ff              MOVS     r1,#0xff
00004a  4668              MOV      r0,sp
00004c  7001              STRB     r1,[r0,#0]
;;;253    		command[1] = 0x01;  
00004e  2101              MOVS     r1,#1
000050  7041              STRB     r1,[r0,#1]
;;;254    		command[2] = 0x00;
000052  2100              MOVS     r1,#0
000054  7081              STRB     r1,[r0,#2]
;;;255    		command[3] = 0x25;
000056  2125              MOVS     r1,#0x25
000058  70c1              STRB     r1,[r0,#3]
;;;256    		Send_Uart_Call(command );		
00005a  f7fffffe          BL       Send_Uart_Call
                  |L5.94|
;;;257    	}
;;;258    	/////////////////////////////////////////////////
;;;259      if ( ( GPA_12 == 0 ) && ( GPA_12 != keyboard[1] ) )
00005e  4832              LDR      r0,|L5.296|
000060  38c0              SUBS     r0,r0,#0xc0
000062  6b00              LDR      r0,[r0,#0x30]
000064  2800              CMP      r0,#0
000066  d112              BNE      |L5.142|
000068  482f              LDR      r0,|L5.296|
00006a  38c0              SUBS     r0,r0,#0xc0
00006c  6b00              LDR      r0,[r0,#0x30]
00006e  492f              LDR      r1,|L5.300|
000070  7849              LDRB     r1,[r1,#1]  ; keyboard
000072  4288              CMP      r0,r1
000074  d00b              BEQ      |L5.142|
;;;260    	{
;;;261        // GPD1 被按下 
;;;262    		command[0] = 0xff;	
000076  21ff              MOVS     r1,#0xff
000078  4668              MOV      r0,sp
00007a  7001              STRB     r1,[r0,#0]
;;;263    		command[1] = 0x01;  
00007c  2101              MOVS     r1,#1
00007e  7041              STRB     r1,[r0,#1]
;;;264    		command[2] = 0x00;
000080  2100              MOVS     r1,#0
000082  7081              STRB     r1,[r0,#2]
;;;265    		command[3] = 0x45;
000084  2145              MOVS     r1,#0x45
000086  70c1              STRB     r1,[r0,#3]
;;;266    		Send_Uart_Call(command );		
000088  f7fffffe          BL       Send_Uart_Call
00008c  e016              B        |L5.188|
                  |L5.142|
;;;267      }else if ( ( GPA_12 == 1 ) && ( GPA_12 != keyboard[1] ) )
00008e  4826              LDR      r0,|L5.296|
000090  38c0              SUBS     r0,r0,#0xc0
000092  6b00              LDR      r0,[r0,#0x30]
000094  2801              CMP      r0,#1
000096  d111              BNE      |L5.188|
000098  4823              LDR      r0,|L5.296|
00009a  38c0              SUBS     r0,r0,#0xc0
00009c  6b00              LDR      r0,[r0,#0x30]
00009e  4923              LDR      r1,|L5.300|
0000a0  7849              LDRB     r1,[r1,#1]  ; keyboard
0000a2  4288              CMP      r0,r1
0000a4  d00a              BEQ      |L5.188|
;;;268      {
;;;269    		//GPD1 被抬起
;;;270    		command[0] = 0xff;	
0000a6  21ff              MOVS     r1,#0xff
0000a8  4668              MOV      r0,sp
0000aa  7001              STRB     r1,[r0,#0]
;;;271    		command[1] = 0x01;  
0000ac  2101              MOVS     r1,#1
0000ae  7041              STRB     r1,[r0,#1]
;;;272    		command[2] = 0x00;
0000b0  2100              MOVS     r1,#0
0000b2  7081              STRB     r1,[r0,#2]
;;;273    		command[3] = 0x25;
0000b4  2125              MOVS     r1,#0x25
0000b6  70c1              STRB     r1,[r0,#3]
;;;274    		Send_Uart_Call(command );		
0000b8  f7fffffe          BL       Send_Uart_Call
                  |L5.188|
;;;275    	}
;;;276    	/////////////////////////////////////////////////////
;;;277    	  if ( ( GPD_1 == 0 ) && ( GPD_1 != keyboard[2] ) )
0000bc  481a              LDR      r0,|L5.296|
0000be  6840              LDR      r0,[r0,#4]
0000c0  2800              CMP      r0,#0
0000c2  d111              BNE      |L5.232|
0000c4  4818              LDR      r0,|L5.296|
0000c6  6840              LDR      r0,[r0,#4]
0000c8  4918              LDR      r1,|L5.300|
0000ca  7889              LDRB     r1,[r1,#2]  ; keyboard
0000cc  4288              CMP      r0,r1
0000ce  d00b              BEQ      |L5.232|
;;;278    	{
;;;279        // GPA12 被按下 
;;;280    		command[0] = 0xff;	
0000d0  21ff              MOVS     r1,#0xff
0000d2  4668              MOV      r0,sp
0000d4  7001              STRB     r1,[r0,#0]
;;;281    		command[1] = 0x00;  
0000d6  2100              MOVS     r1,#0
0000d8  7041              STRB     r1,[r0,#1]
;;;282    		command[2] = 0x01;
0000da  2101              MOVS     r1,#1
0000dc  7081              STRB     r1,[r0,#2]
;;;283    		command[3] = 0x00;	
0000de  2100              MOVS     r1,#0
0000e0  70c1              STRB     r1,[r0,#3]
;;;284    		Send_Uart_Call(command );		
0000e2  f7fffffe          BL       Send_Uart_Call
0000e6  e012              B        |L5.270|
                  |L5.232|
;;;285      }else if ( ( GPD_1 == 1 ) && ( GPD_1 != keyboard[2] ) )
0000e8  480f              LDR      r0,|L5.296|
0000ea  6840              LDR      r0,[r0,#4]
0000ec  2801              CMP      r0,#1
0000ee  d10e              BNE      |L5.270|
0000f0  480d              LDR      r0,|L5.296|
0000f2  6840              LDR      r0,[r0,#4]
0000f4  490d              LDR      r1,|L5.300|
0000f6  7889              LDRB     r1,[r1,#2]  ; keyboard
0000f8  4288              CMP      r0,r1
0000fa  d008              BEQ      |L5.270|
;;;286      {
;;;287    		//GPA12 被抬起
;;;288    		command[0] = 0xff;	
0000fc  21ff              MOVS     r1,#0xff
0000fe  4668              MOV      r0,sp
000100  7001              STRB     r1,[r0,#0]
;;;289    		command[1] = 0x00;  
000102  2100              MOVS     r1,#0
000104  7041              STRB     r1,[r0,#1]
;;;290    		command[2] = 0x00;
000106  7081              STRB     r1,[r0,#2]
;;;291    		command[3] = 0x00;
000108  70c1              STRB     r1,[r0,#3]
;;;292    		Send_Uart_Call(command );				
00010a  f7fffffe          BL       Send_Uart_Call
                  |L5.270|
;;;293    	}
;;;294    	/////////////////////////////////////////////////////
;;;295    
;;;296      keyboard[0] = GPD_0 ;
00010e  4806              LDR      r0,|L5.296|
000110  6800              LDR      r0,[r0,#0]
000112  4906              LDR      r1,|L5.300|
000114  7008              STRB     r0,[r1,#0]
;;;297      keyboard[1] = GPA_12 ;
000116  4804              LDR      r0,|L5.296|
000118  38c0              SUBS     r0,r0,#0xc0
00011a  6b00              LDR      r0,[r0,#0x30]
00011c  7048              STRB     r0,[r1,#1]
;;;298      keyboard[2] = GPD_1;
00011e  4802              LDR      r0,|L5.296|
000120  6840              LDR      r0,[r0,#4]
000122  7088              STRB     r0,[r1,#2]
;;;299    	
;;;300    }
000124  bd1c              POP      {r2-r4,pc}
;;;301    
                          ENDP

000126  0000              DCW      0x0000
                  |L5.296|
                          DCD      0x500042c0
                  |L5.300|
                          DCD      keyboard

                          AREA ||i.UART_Configuration||, CODE, READONLY, ALIGN=1

                  UART_Configuration PROC
;;;183     */
;;;184    void UART_Configuration(void)
000000  b50e              PUSH     {r1-r3,lr}
;;;185    {
;;;186        STR_UART_T param;
;;;187      
;;;188        /* Select UART Clock Source From 12MHz */
;;;189        DrvSYS_SelectIPClockSource(E_SYS_UART_CLKSRC, 0x00);  //使能UART时钟
000002  2100              MOVS     r1,#0
000004  2006              MOVS     r0,#6
000006  f7fffffe          BL       DrvSYS_SelectIPClockSource
;;;190    
;;;191        param.u32BaudRate = UART0_BAUD; //波特率
00000a  204b              MOVS     r0,#0x4b
00000c  01c0              LSLS     r0,r0,#7
00000e  9000              STR      r0,[sp,#0]
;;;192        param.u8cDataBits = DRVUART_DATABITS_8; //数据位
000010  2103              MOVS     r1,#3
000012  4668              MOV      r0,sp
000014  7101              STRB     r1,[r0,#4]
;;;193        param.u8cStopBits = DRVUART_STOPBITS_1; //停止位
000016  2100              MOVS     r1,#0
000018  7141              STRB     r1,[r0,#5]
;;;194        param.u8cParity = DRVUART_PARITY_NONE;  //校验位
00001a  7181              STRB     r1,[r0,#6]
;;;195        param.u8cRxTriggerLevel = DRVUART_FIFO_4BYTES;   //FIFO存储深度63字节
00001c  2101              MOVS     r1,#1
00001e  71c1              STRB     r1,[r0,#7]
;;;196        param.u8TimeOut = 0;  //FIFO超时设定
000020  2100              MOVS     r1,#0
000022  7201              STRB     r1,[r0,#8]
;;;197     
;;;198        DrvGPIO_InitFunction(E_FUNC_UART1);   //复用功能引脚设置
000024  202c              MOVS     r0,#0x2c
000026  f7fffffe          BL       DrvGPIO_InitFunction
;;;199        DrvUART_Open(UART_PORT1, &param);   //串口usart1开启、结构体整体赋值
00002a  4669              MOV      r1,sp
00002c  2001              MOVS     r0,#1
00002e  0500              LSLS     r0,r0,#20
000030  f7fffffe          BL       DrvUART_Open
;;;200    }
000034  bd0e              POP      {r1-r3,pc}
;;;201    
                          ENDP


                          AREA ||i.delay_loop||, CODE, READONLY, ALIGN=1

                  delay_loop PROC
;;;67     
;;;68     void delay_loop(void)
000000  2000              MOVS     r0,#0
;;;69      {
;;;70         uint32_t j;
;;;71      		for(j=0;j<60;j++);		
000002  e000              B        |L7.6|
                  |L7.4|
000004  1c40              ADDS     r0,r0,#1
                  |L7.6|
000006  283c              CMP      r0,#0x3c
000008  d3fc              BCC      |L7.4|
;;;72     
;;;73      }
00000a  4770              BX       lr
;;;74      
                          ENDP


                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;80      */
;;;81     int main(void)
000000  f7fffffe          BL       InitSystem
;;;82     { 
;;;83     	InitSystem();	
;;;84     	while(1);
000004  bf00              NOP      
                  |L8.6|
000006  e7fe              B        |L8.6|
;;;85     	
;;;86     }
;;;87     
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  buffer
000000  11121314          DCB      0x11,0x12,0x13,0x14
                  keyboard
000004  01010100          DCB      0x01,0x01,0x01,0x00
                  pupin
000008  03000000          DCB      0x03,0x00,0x00,0x00
                          DCD      0x00000000
000010  03000000          DCB      0x03,0x00,0x00,0x00
                          DCD      0x00000001
000018  03000000          DCB      0x03,0x00,0x00,0x00
                          DCD      0x00000002
000020  03000000          DCB      0x03,0x00,0x00,0x00
                          DCD      0x00000003
000028  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000005
000030  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000004
000038  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000003
000040  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000002
000048  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000001
000050  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
000058  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x0000000c
000060  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x0000000d
000068  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      0x00000007
000070  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      0x00000006
000078  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x0000000f
000080  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x0000000f
000088  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      0x0000000c
000090  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000009
000098  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      0x00000008

                  __ARM_use_no_argv EQU 0
